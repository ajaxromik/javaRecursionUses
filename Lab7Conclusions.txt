n0: 13
Solution 1 broke at 13! because it is the first number over the int's maximum of 2^31-1
This can be improved by using the long primitive type.

n1: 21
Solution 2 broke at 21! because it was the first number to reach over the
maximum of the long primitive type. This could be further improved
by using a BigInteger

n2: 11807
I'm not quite sure what the accuracy limitations of this approach might be.
One guess is that the BigInteger constructors can only take up to an integer the size of 2 raised to the power of the max integer.
11807 is where a stack overflow occurs.


I was able to see a StackOverflowError at the recursive factorial attempt
with an 11807 because there was too many calls to the factorial method for 
the computer to handle.

I was able to create an OutOfMemoryError by allocating an array of 
primitive long variables and the length of 133693480.

This was the number right after the max that 1G of memory could handle
on the heap.


Prelab Problem 1 was nice and easy

Problem 2F:
Method 3 is the most efficient because it does the least amount of 
operations. 

Method 1 is easily the worst with its excessive amount of 
unnecessary function calls. 

Method 2 has a for loop that will end up running multiple times for the 
entire length of k* for large numbers.

Method 3 however simply will do a multiplication and a division for the
length of k*. It's much simpler code and a much more efficient solution.


Problem 3:
I have learned why recursion is extremely inefficient in this lab, and 
that there is often ways around the recursive solution, either by 
storing the necessary data in order to save from recreating it,
or by finding a solution that cuts off the excess steps.